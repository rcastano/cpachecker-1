#!/usr/bin/python

import argparse
import bz2
import os
import re
import shutil
import subprocess
import os.path

from lxml import etree
from time import strftime

def script_path():
    return os.path.dirname(os.path.realpath(__file__))

# Following instructions for "Setting up Cgroups on Systems with systemd"
# https://github.com/sosy-lab/benchexec/blob/master/doc/INSTALL.md
def cgroup_init():
    cgroup_dir = '/sys/fs/cgroup/'
    cgroup_files = [
        cgroup_dir + 'cpuset/system.slice/benchexec-cgroup.service/tasks',
        cgroup_dir + 'cpuacct/system.slice/benchexec-cgroup.service/tasks',
        cgroup_dir + 'memory/system.slice/benchexec-cgroup.service/tasks',
        cgroup_dir + 'freezer/system.slice/benchexec-cgroup.service/tasks']
    for file in cgroup_files:
        with open(file, 'w') as f:
            print >> f, str(os.getpid())

time_str = strftime("%Y%m%d_%H%M%S")
backup_dir = os.path.join(
    script_path(), 'backup_' + time_str)
results_dir = os.path.join(script_path(), 'results_' + time_str)
temp_dir = os.path.join(script_path(), 'temp_benchexec_files')

def create_temp_dirs():
    if not os.path.exists(results_dir):
        os.makedirs(results_dir)
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    os.makedirs(temp_dir)

# Moves files generated by previous executions to a fresh backup folder.
# Files moved: my-programs.*assumption_automaton.*
# Destination: backup_{date string}/
# Destination root directory must already exist.
# Subdirectory structure is preserved.
def backup_assumption_automata():
    instances_dir = os.path.join(script_path(), 'my-programs')
    for path, dirnames, filenames in os.walk(instances_dir):
        for filename in filenames:
                # Assumption Automata files
            if ('assumption_automaton' in filename or
                # File indicating finished instances:
                # (generate-[explicit|predicate]-900.original.set)
                re.match(pattern=r'.*generate.*\.set',string=filename)):
                dest_path = os.path.join(backup_dir, path)
                if not os.path.exists(dest_path):
                    os.makedirs(dest_path)
                src_file = os.path.join(path, filename)
                dest_file = os.path.join(dest_path, filename)
                shutil.move(src=src_file, dst=dest_file)

cpachecker_subdir = 'cpachecker_files'
cpachecker_dir = os.path.abspath(
    os.path.join(script_path(), cpachecker_subdir))

# Moves files generated by previous executions to a fresh backup folder.
# Files moved: cpachecker_files/benchexec-outputs/.*
# Destination: backup_{date string}/
# Destination root directory must already exist.
# Subdirectory structure is preserved.
def backup_results():
    assert not os.path.exists(temp_dir) or len(os.listdir(temp_dir)) == 0
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
    if os.path.exists(results_dir):
        shutil.move(src=results_dir, dst=backup_dir)
    outputs_dir = os.path.join(cpachecker_dir, 'benchexec-outputs')
    if os.path.exists(outputs_dir):
        backup_cpachecker_dir = os.path.join(backup_dir, cpachecker_subdir)
        shutil.makedirs(backup_cpachecker_dir)
        shutil.move(src=outputs_dir, dst=backup_cpachecker_dir)

# Backup all files created by previous executions of the experiments.
def backup_old_files():
    assert not os.file.exists(backup_dir)
    os.makedirs(backup_dir)
    backup_assumption_automata()
    backup_result()

# Running CPAchecker over the set of files defined in
# my-programs/instances.set.
# Each instance will be analyzed twice (once for each
# '--rundefinition' included in the command-line parameters),
# once with lazy predicate analysis (generate-predicate-900) and
# the other with explicit value analysis (generate-explicit-900).
# The exact CPAchecker configuration options are defined in
# the file experiments/generate.xml.
# The time limit for each execution of CPAchecker is 900 seconds.
# We use a soft limit to enable CPAchecker to then produce an
# Assumption Automaton.
# We allow for 100 additional seconds, after which a hard limit is
# enforced.
# The only output that is preserved from this phase are the Assumption
# Automata generated. These will be created in the same directory
# as the instance being verified using the following naming
# convention: {instance name}.{technique}.assumption_automaton
# For example, for the instance my-programs/fse12/systemc/toy.c, the 
# files my-programs/fse12/systemc/toy.c.explicit.assumption_automaton
# and my-programs/fse12/systemc/toy.c.predicate.assumption_automaton will
# be created.
# CPAchecker creates an invalid Assumption Automaton when the result of
# verification is conclusive (either a bug is found or the property is
# proved to hold).
def attempt_verification():
    subprocess.check_call([
        # BenchExec is already bundled with CPAchecker and can
        # be called using this script.
        './scripts/benchmark.py',
        '-o', '../temp_benchexec_files/',
        '--rundefinition', 'generate-predicate-900',
        '--rundefinition', 'generate-explicit-900',
        '--limitCores', '1',
        '../experiments/generate.xml'],
        cwd=cpachecker_dir)

# We filter files that yielded an inconclusive result after the alloted
# CPU time limit.
# We create two .set files in order to tell whether the technique that
# was used for the initial verification attempt was explicit value
# analysis (generate-explicit.original.set) or lazy predicate
# abstraction (generate-predicate.original.set).
# The input to this method are the two .xml.bz2 files produced by
# BenchExec with the results of the first phase, i.e., the initial
# verification attempt.
def isolate_incomplete_attempts():
    result_files = [
        os.path.join(results_dir, file)
        for file in os.listdir(results_dir) if file.endswith('bz2')]
    assert len(result_files) == 2
    assert 'generate-explicit' in result_files[0]
    assert 'generate-predicate' in result_files[1]
    for result_xml in result_files:

        with bz2.BZ2File(result_xml, 'r') as f:
            t = etree.parse(f)
            results = t.xpath('//result')
            assert len(results) == 1
            result = results[0]
            bench_name = result.get('name')
            instances_dir = os.path.abspath(
                os.path.join(script_path(), 'my-programs'))

            incomplete_attempts = []
            for run in result.xpath('./run'):
                status = run.xpath(
                    "./column[@title='status']")[0].get('value')
                if status == 'unknown':
                    # This corresponds to the file name, relative to the
                    # CPAchecker directory.
                    rel_inputfile = run.get('name')
                    abs_inputfile = os.path.abspath(
                        os.path.join(cpachecker_dir, rel_inputfile))
                    # This corresponds to the file name, relative to
                    # where the .set file will be located.
                    rel_inputfile = os.path.relpath(
                        path=abs_inputfile, start=instances_dir)
                    incomplete_attempts.append(rel_inputfile)
            output_file = bench_name + '.original.set'
            with open(os.path.join(instances_dir, output_file), 'w') as f:
                for filename in incomplete_attempts:
                    print >> f, filename

# Generating an Execution Report (ER) for each of the instances defined in
# my-programs/generate-explicit-900.original.set and 
# generate-predicate-900.original.set.
# 
# The input to the ER generation will be both the instance and the
# Assumption Automaton produced after the initial verification attempt.
# For this reason, two ERs could be produced for an instance if both lazy
# predicate abstraction and explicit value analysis produced an
# inconclusive result in the first phase.
# This is reflected in the two calls to the method
# generate_ER_from_verification_with().
#
# To generate an ER, we need to produce two components, S (Safe)
# and F (Frontier). In order to generate these components, we
# encode the task as two indepenent verification problems.
# This leads us to two sets of run definitions:
#       'produce-witnesses-frontier-*' and
#       'produce-witnesses-safe-*'
# These two verification problems are then solved using two different
# techniques, in order to assess their performance. Therefore, the run
# definitions sets of the second phase can be subdivided into four:
#       'produce-witnesses-frontier-predicate-*'
#       'produce-witnesses-frontier-explicit-*'
#       'produce-witnesses-safe-predicate-*'
#       'produce-witnesses-safe-explicit-*'
# Finally, the origin of the Assumption Automaton, i.e. which technique
# was used for the initial verification attempt, subsequently divides
# the run definitions into a total of eight:
#       'produce-witnesses-frontier-predicate-from-explicit'
#       'produce-witnesses-frontier-predicate-from-predicate'
#       'produce-witnesses-frontier-explicit-from-explicit'
#       'produce-witnesses-frontier-explicit-from-predicate'
#       'produce-witnesses-safe-predicate-from-explicit'
#       'produce-witnesses-safe-predicate-from-predicate'
#       'produce-witnesses-safe-explicit-from-explicit'
#       'produce-witnesses-safe-explicit-from-predicate'
def generate_ERs(only_first_witness):
    one_cex_spec = os.path.join(
        script_path(), 'experiments', 'experiment900_one_cex.xml')
    def change_xml_to_produce_only_one_witness():
        dest_xml = one_cex_spec
        shutil.copyfile(
            src=os.path.join(
                script_path(), 'experiments', 'experiment900.xml'),
            dst=dest_xml)
        subprocess.check_call([
            'sed', "'s/.*stopAfterError.*//'", dest_xml], cwd=script_path())
    if only_first_witness:
        change_xml_to_produce_only_one_witness()

    def generate_ER_from_verification_with(technique, only_first_witness):
        spec = '../experiments/experiment900.xml'
        if only_first_witness:
            spec = one_cex_spec
        task = 'from-' + technique
        subprocess.check_call([
            # BenchExec is already bundled with CPAchecker and can
            # be called using this script.
            './scripts/benchmark.py',
            '-o', '../temp_benchexec_files/',
            '--tasks', task + '-900',
            '--rundefinition',
                'produce-witnesses-frontier-predicate-' + task,
            '--rundefinition',
                'produce-witnesses-frontier-explicit-' + task,
            '--rundefinition',
                'produce-witnesses-safe-predicate-' + task,
            '--rundefinition',
                'produce-witnesses-safe-explicit-' + task,
            '--limitCores', '1',
            spec],
            cwd=cpachecker_dir)

    generate_ER_from_verification_with('predicate', only_first_witness)
    generate_ER_from_verification_with('explicit', only_first_witness)

def move_temp_files_to_results():
    for f in os.listdir(temp_dir):
        dest_file = os.path.join(results_dir, f)
        if os.path.exists(dest_file):
            raise Exception('File to be copied already exists.')
        shutil.move(
            src=os.path.join(temp_dir, f),
            dst=dest_file)

def generate_graphics():
    import make_tables
    tables_dir = os.path.join(script_path(), 'tables')
    os.makedirs(tables_dir)
    def get_second_phase_results_using(
        first_phase_technique, second_phase_technique, files):
        # produce[...]-explicit-from-predicate.from-predicate-900
        # produce[...]-{2nd phase}-from-{1st phase}.from-{1st phase}-900
        # technique 1:             {  match this  } {    or this   }
        # technique 2: {  match this  }

        res = [
            f for f in files
            if (second_phase_technique + '-from') in f and
            ('from-' + first_phase_technique) in f]
        assert len(res) == 1
        return res
    def parse_xml(fn):
        with open(fn) as f:
            t = etree.parse(f)
            results = t.xpath('//result')
            assert len(results) == 1
            result = results[0]
        return result
            
    def make_table_for_component(first_phase_technique, comp, fn):
        assert comp == 'safe' or comp == 'frontier'
        files = [ f for f in os.listdir(results_dir) if comp in f ]

        second_phase_explicit = \
            get_second_phase_results_using(
                first_phase_technique, 'explicit', files)[0]
        second_phase_predicate = \
            get_second_phase_results_using(
                first_phase_technique, 'predicate', files)[0]
        explicit_xml = parse_xml(second_phase_explicit)
        predicate_xml = parse_xml(second_phase_predicate)
        with open(fn) as f_out:
            make_table.handle_bench_result(
                explicit_xml, predicate_xml, f_out)
    make_table_for_component(
        first_phase_technique='explicit',
        comp='safe',
        fn=os.path.join(tables_dir, 'table1.tex'))

    make_table_for_component(
        first_phase_technique='predicate',
        comp='safe',
        fn=os.path.join(tables_dir, 'table2.tex'))

    make_table_for_component(
        first_phase_technique='predicate',
        comp='frontier',
        fn=os.path.join(tables_dir, 'table3.tex'))

    make_table_for_component(
        first_phase_technique='explicit',
        comp='frontier',
        fn=os.path.join(tables_dir, 'table4.tex'))

def run_experiments(only_first_witness):
    cgroup_init()
    create_temp_dirs()
    # Backup any existing files from previous runs. 
    backup_old_files()
    # Run CPAchecker on a set of instances.
    # The execution is monitored using BenchExec.
    attempt_verification()

    move_temp_files_to_results()

    # Creates generate-[explicit|predicate].original.set files that
    # indicate which files to generate an Execution Report for.
    isolate_incomplete_attempts()
    # Generate Execution Reports for the subset of instances for which the
    # verification attempt yielded inconclusive results.
    # This is achieved by running CPAchecker with a custom specification
    # and monitored using BenchExec to ensure repeatability.
    generate_ERs(only_first_witness)

    # Generates Tables 1 to 4 from the results of the execution.
    generate_graphics()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "--only_one_witness",
            action='store_true',
            help=("Produce at most one witness in each" +
                  "Execution Report component."))
    args = parser.parse_args()
    run_experiments(args.only_one_witness)
